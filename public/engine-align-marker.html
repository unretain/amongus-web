<!DOCTYPE html>
<html>
<head>
    <title>Engine Align - Element Marker</title>
    <style>
        body {
            background: #1a1a2e;
            color: #fff;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 15px;
        }
        #main-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .panel {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 8px;
        }
        #source-panel {
            flex: 0 0 600px;
            max-height: 90vh;
            overflow: auto;
        }
        #info-panel {
            flex: 1;
            min-width: 350px;
        }
        h3 {
            margin-top: 0;
            color: #0ff;
        }
        .controls {
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }
        button {
            padding: 8px 14px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            background: #444;
            color: #fff;
        }
        button:hover { background: #666; }
        button.active { background: #0088ff; }
        .danger { background: #ff4444 !important; }
        .success { background: #00aa00 !important; }
        .warning { background: #ff8800 !important; }
        input[type="text"] {
            width: 150px;
            padding: 6px;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            border-radius: 4px;
        }
        #source-canvas {
            border: 2px solid #444;
            cursor: crosshair;
            display: block;
        }
        #output {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 5px;
            max-height: 400px;
            overflow: auto;
            font-family: monospace;
            font-size: 12px;
            white-space: pre;
            margin-top: 15px;
        }
        .marker-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            margin: 4px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
        }
        .marker-item:hover { background: rgba(255,255,255,0.2); }
        .marker-item.selected { background: rgba(0,136,255,0.4); border: 1px solid #0088ff; }
        .marker-item .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        #coords {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
            z-index: 100;
        }
        .section-title {
            color: #ff0;
            font-size: 14px;
            margin: 15px 0 8px 0;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }
        .help-text {
            color: #888;
            font-size: 12px;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <h2 style="color: #0ff; margin-top: 0;">Engine Align - Element Marker</h2>

    <div id="main-container">
        <div id="source-panel" class="panel">
            <h3>Engine Align Base</h3>

            <div class="controls">
                <label>Zoom:
                    <button onclick="setZoom(1)">1x</button>
                    <button onclick="setZoom(1.5)" class="active">1.5x</button>
                    <button onclick="setZoom(2)">2x</button>
                    <button onclick="setZoom(3)">3x</button>
                </label>
                <span id="loadStatus" style="margin-left: 10px; color: #0f0;"></span>
            </div>

            <canvas id="source-canvas"></canvas>

            <p class="help-text">Click and drag to draw freehand. Release mouse to finish shape. Press Escape to cancel.</p>
        </div>

        <div id="info-panel" class="panel">
            <h3>Marked Elements</h3>

            <div class="controls">
                <label>Name: <input type="text" id="markerName" value="element1" placeholder="Element name"></label>
                <input type="color" id="markerColor" value="#00ff00" style="width: 40px; height: 30px; padding: 0; border: none;">
            </div>

            <div class="section-title">Markers (<span id="marker-count">0</span>)</div>
            <div id="marker-list">Click on image to start marking</div>

            <div class="controls" style="margin-top: 15px;">
                <button class="danger" onclick="clearAllMarkers()">Clear All</button>
                <button class="success" onclick="exportMarkers()">Export Coords</button>
                <button onclick="copyToClipboard()">Copy to Clipboard</button>
            </div>

            <div id="output">// Marker coordinates will appear here</div>
        </div>
    </div>

    <div id="coords">X: 0, Y: 0</div>

    <script>
        const sourceCanvas = document.getElementById('source-canvas');
        const ctx = sourceCanvas.getContext('2d');

        // State
        let zoom = 1.5;
        let sourceImg = null;

        // Markers array - each marker has name, color, points[]
        let markers = [];
        let selectedMarkerIndex = -1;

        // Current drawing state
        let currentPoints = [];
        let isDrawing = false;

        // Load the image
        function loadImage() {
            sourceImg = new Image();
            sourceImg.onload = () => {
                document.getElementById('loadStatus').textContent = `${sourceImg.width}x${sourceImg.height}`;
                drawCanvas();
            };
            sourceImg.onerror = () => {
                document.getElementById('loadStatus').textContent = 'Failed to load!';
            };
            sourceImg.src = '/assets/tasks/engineAlign_base.png';
        }

        function setZoom(z) {
            zoom = z;
            document.querySelectorAll('#source-panel .controls button').forEach(b => {
                if (b.textContent.match(/^[\d.]+x$/)) b.classList.remove('active');
            });
            event.target.classList.add('active');
            drawCanvas();
        }

        function drawCanvas() {
            if (!sourceImg || !sourceImg.complete) return;

            sourceCanvas.width = sourceImg.width * zoom;
            sourceCanvas.height = sourceImg.height * zoom;

            // Draw image
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(sourceImg, 0, 0, sourceCanvas.width, sourceCanvas.height);

            // Draw all saved markers
            markers.forEach((marker, index) => {
                drawMarker(marker, index === selectedMarkerIndex);
            });

            // Draw current drawing points
            if (currentPoints.length > 0) {
                drawPoints(currentPoints, document.getElementById('markerColor').value, true);
            }
        }

        function drawMarker(marker, selected) {
            if (marker.points.length < 2) return;

            ctx.strokeStyle = marker.color;
            ctx.lineWidth = selected ? 3 : 2;
            ctx.fillStyle = marker.color.replace(')', ', 0.2)').replace('rgb', 'rgba').replace('#', '');

            // Convert hex to rgba for fill
            const hex = marker.color;
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.25)`;

            ctx.beginPath();
            ctx.moveTo(marker.points[0].x * zoom, marker.points[0].y * zoom);
            for (let i = 1; i < marker.points.length; i++) {
                ctx.lineTo(marker.points[i].x * zoom, marker.points[i].y * zoom);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw points
            ctx.fillStyle = marker.color;
            for (const pt of marker.points) {
                ctx.beginPath();
                ctx.arc(pt.x * zoom, pt.y * zoom, selected ? 5 : 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw label
            if (marker.points.length > 0) {
                const centerX = marker.points.reduce((sum, p) => sum + p.x, 0) / marker.points.length;
                const centerY = marker.points.reduce((sum, p) => sum + p.y, 0) / marker.points.length;

                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.strokeText(marker.name, centerX * zoom, centerY * zoom);
                ctx.fillText(marker.name, centerX * zoom, centerY * zoom);
            }
        }

        function drawPoints(points, color, isCurrentDrawing) {
            if (points.length === 0) return;

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.setLineDash(isCurrentDrawing ? [5, 5] : []);

            ctx.beginPath();
            ctx.moveTo(points[0].x * zoom, points[0].y * zoom);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x * zoom, points[i].y * zoom);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw points
            ctx.fillStyle = color;
            for (const pt of points) {
                ctx.beginPath();
                ctx.arc(pt.x * zoom, pt.y * zoom, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Mouse events - FREEHAND LASSO
        sourceCanvas.addEventListener('mousedown', (e) => {
            const rect = sourceCanvas.getBoundingClientRect();
            const x = Math.round((e.clientX - rect.left) / zoom);
            const y = Math.round((e.clientY - rect.top) / zoom);

            // Start new freehand drawing
            currentPoints = [{ x, y }];
            isDrawing = true;
            drawCanvas();
        });

        sourceCanvas.addEventListener('mousemove', (e) => {
            const rect = sourceCanvas.getBoundingClientRect();
            const x = Math.round((e.clientX - rect.left) / zoom);
            const y = Math.round((e.clientY - rect.top) / zoom);

            document.getElementById('coords').textContent = `X: ${x}, Y: ${y}`;

            // If drawing, add points as we drag (freehand)
            if (isDrawing) {
                // Only add point if it's far enough from the last point (reduces noise)
                const lastPt = currentPoints[currentPoints.length - 1];
                const dist = Math.sqrt((x - lastPt.x) ** 2 + (y - lastPt.y) ** 2);
                if (dist > 3) { // Minimum distance between points
                    currentPoints.push({ x, y });
                    drawCanvas();
                }
            }
        });

        sourceCanvas.addEventListener('mouseup', (e) => {
            if (isDrawing && currentPoints.length >= 5) {
                // Save the marker
                const name = document.getElementById('markerName').value || `element${markers.length + 1}`;
                const color = document.getElementById('markerColor').value;

                // Simplify points - reduce to every Nth point to keep coords manageable
                const simplified = simplifyPoints(currentPoints, 5);

                markers.push({
                    name: name,
                    color: color,
                    points: simplified
                });

                // Auto-increment name
                const match = name.match(/^(.+?)(\d+)$/);
                if (match) {
                    document.getElementById('markerName').value = match[1] + (parseInt(match[2]) + 1);
                } else {
                    document.getElementById('markerName').value = name + '2';
                }

                // Cycle color
                const colors = ['#00ff00', '#ff0000', '#0088ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800'];
                const currentColorIndex = colors.indexOf(color);
                const nextColor = colors[(currentColorIndex + 1) % colors.length];
                document.getElementById('markerColor').value = nextColor;

                currentPoints = [];
                isDrawing = false;
                updateMarkerList();
                drawCanvas();
                exportMarkers();
            } else {
                // Not enough points, cancel
                currentPoints = [];
                isDrawing = false;
                drawCanvas();
            }
        });

        sourceCanvas.addEventListener('mouseleave', (e) => {
            // If we leave canvas while drawing, cancel
            if (isDrawing) {
                currentPoints = [];
                isDrawing = false;
                drawCanvas();
            }
        });

        // Simplify points by keeping every Nth point
        function simplifyPoints(points, keepEvery) {
            if (points.length <= 10) return points;
            const result = [];
            for (let i = 0; i < points.length; i += keepEvery) {
                result.push(points[i]);
            }
            // Always include the last point
            if (result[result.length - 1] !== points[points.length - 1]) {
                result.push(points[points.length - 1]);
            }
            return result;
        }

        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                currentPoints = [];
                isDrawing = false;
                drawCanvas();
            }
            if (e.key === 'Delete' && selectedMarkerIndex >= 0) {
                markers.splice(selectedMarkerIndex, 1);
                selectedMarkerIndex = -1;
                updateMarkerList();
                drawCanvas();
                exportMarkers();
            }
            // Ctrl+Z to undo last marker
            if (e.ctrlKey && e.key === 'z' && markers.length > 0) {
                markers.pop();
                updateMarkerList();
                drawCanvas();
                exportMarkers();
            }
        });

        function updateMarkerList() {
            const list = document.getElementById('marker-list');
            document.getElementById('marker-count').textContent = markers.length;

            if (markers.length === 0) {
                list.innerHTML = 'Click on image to start marking';
                return;
            }

            list.innerHTML = markers.map((m, i) => {
                const bounds = getBounds(m.points);
                return `<div class="marker-item${selectedMarkerIndex === i ? ' selected' : ''}" onclick="selectMarker(${i})">
                    <span><span class="color-dot" style="background: ${m.color};"></span>${m.name}</span>
                    <span style="color: #888; font-size: 11px;">${m.points.length} pts (${bounds.w}x${bounds.h})</span>
                    <button onclick="event.stopPropagation(); removeMarker(${i})" style="padding: 2px 8px;">X</button>
                </div>`;
            }).join('');
        }

        function getBounds(points) {
            if (points.length === 0) return { x: 0, y: 0, w: 0, h: 0 };
            const xs = points.map(p => p.x);
            const ys = points.map(p => p.y);
            const minX = Math.min(...xs);
            const minY = Math.min(...ys);
            const maxX = Math.max(...xs);
            const maxY = Math.max(...ys);
            return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
        }

        function selectMarker(index) {
            selectedMarkerIndex = selectedMarkerIndex === index ? -1 : index;
            updateMarkerList();
            drawCanvas();
        }

        function removeMarker(index) {
            markers.splice(index, 1);
            if (selectedMarkerIndex === index) selectedMarkerIndex = -1;
            else if (selectedMarkerIndex > index) selectedMarkerIndex--;
            updateMarkerList();
            drawCanvas();
            exportMarkers();
        }

        function clearAllMarkers() {
            if (markers.length === 0 && currentPoints.length === 0) return;
            if (confirm('Clear all markers?')) {
                markers = [];
                currentPoints = [];
                selectedMarkerIndex = -1;
                isDrawing = false;
                updateMarkerList();
                drawCanvas();
                document.getElementById('output').textContent = '// Marker coordinates will appear here';
            }
        }

        function exportMarkers() {
            if (markers.length === 0) {
                document.getElementById('output').textContent = '// No markers yet';
                return;
            }

            let code = '// Engine Align Element Markers\n';
            code += '// Image size: ' + (sourceImg ? `${sourceImg.width}x${sourceImg.height}` : 'unknown') + '\n\n';

            code += 'const engineAlignMarkers = {\n';

            markers.forEach(m => {
                const bounds = getBounds(m.points);
                code += `    '${m.name}': {\n`;
                code += `        bounds: { x: ${bounds.x}, y: ${bounds.y}, w: ${bounds.w}, h: ${bounds.h} },\n`;
                code += `        center: { x: ${Math.round(bounds.x + bounds.w/2)}, y: ${Math.round(bounds.y + bounds.h/2)} },\n`;
                code += `        points: [\n`;
                m.points.forEach(p => {
                    code += `            { x: ${p.x}, y: ${p.y} },\n`;
                });
                code += `        ]\n`;
                code += `    },\n`;
            });

            code += '};\n';

            document.getElementById('output').textContent = code;
        }

        function copyToClipboard() {
            const output = document.getElementById('output').textContent;
            navigator.clipboard.writeText(output).then(() => {
                alert('Copied to clipboard!');
            });
        }

        // Initialize
        loadImage();
        updateMarkerList();
    </script>
</body>
</html>
